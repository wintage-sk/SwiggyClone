"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _plugin() {
  const data = require("@parcel/plugin");
  _plugin = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("@parcel/utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));
  _nullthrows = function () {
    return data;
  };
  return data;
}
function _diagnostic() {
  const data = _interopRequireWildcard(require("@parcel/diagnostic"));
  _diagnostic = function () {
    return data;
  };
  return data;
}
function _nodeResolverCore() {
  const data = _interopRequireDefault(require("@parcel/node-resolver-core"));
  _nodeResolverCore = function () {
    return data;
  };
  return data;
}
function _assert() {
  const data = _interopRequireDefault(require("assert"));
  _assert = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function errorToThrowableDiagnostic(error, dependency) {
  return new (_diagnostic().default)({
    diagnostic: {
      message: error,
      codeFrames: dependency.loc ? [{
        codeHighlights: [(0, _diagnostic().convertSourceLocationToHighlight)(dependency.loc)]
      }] : undefined
    }
  });
}
var _default = new (_plugin().Resolver)({
  async resolve({
    dependency,
    options,
    specifier,
    pipeline,
    logger
  }) {
    var _dependency$resolveFr, _dependency$meta;
    if (!(0, _utils().isGlob)(specifier)) {
      return;
    }
    let sourceAssetType = (0, _nullthrows().default)(dependency.sourceAssetType);
    let sourceFile = (0, _nullthrows().default)((_dependency$resolveFr = dependency.resolveFrom) !== null && _dependency$resolveFr !== void 0 ? _dependency$resolveFr : dependency.sourcePath);
    let error;
    if (sourceAssetType !== 'js' && sourceAssetType !== 'css') {
      error = `Glob imports are not supported in ${sourceAssetType} files.`;
    } else if (dependency.specifierType === 'url' && !((_dependency$meta = dependency.meta) !== null && _dependency$meta !== void 0 && _dependency$meta.isCSSImport)) {
      error = 'Glob imports are not supported in URL dependencies.';
    }
    if (error) {
      throw errorToThrowableDiagnostic(error, dependency);
    }
    let invalidateOnFileCreate = [];
    let invalidateOnFileChange = new Set();

    // if the specifier does not start with /, ~, or . then it's not a path but package-ish - we resolve
    // the package first, and then append the rest of the path
    if (!/^[/~.]/.test(specifier)) {
      // Globs are not paths - so they always use / (see https://github.com/micromatch/micromatch#backslashes)
      let splitOn = specifier.indexOf('/');
      if (specifier.charAt(0) === '@') {
        splitOn = specifier.indexOf('/', splitOn + 1);
      }

      // Since we've already asserted earlier that there is a glob present, it shouldn't be
      // possible for there to be only a package here without any other path parts (e.g. `import('pkg')`)
      (0, _assert().default)(splitOn !== -1);
      let pkg = specifier.substring(0, splitOn);
      let rest = specifier.substring(splitOn + 1);

      // This initialisation code is copied from the DefaultResolver
      const resolver = new (_nodeResolverCore().default)({
        fs: options.inputFS,
        projectRoot: options.projectRoot,
        packageManager: options.shouldAutoInstall ? options.packageManager : undefined,
        mode: options.mode,
        logger
      });
      let result;
      try {
        result = await resolver.resolve({
          filename: pkg + '/package.json',
          parent: dependency.resolveFrom,
          specifierType: 'esm',
          env: dependency.env,
          sourcePath: dependency.sourcePath
        });
      } catch (err) {
        if (err instanceof _diagnostic().default) {
          // Return instead of throwing so we can provide invalidations.
          return {
            diagnostics: err.diagnostics,
            invalidateOnFileCreate,
            invalidateOnFileChange: [...invalidateOnFileChange]
          };
        } else {
          throw err;
        }
      }
      if (!result || !result.filePath) {
        throw errorToThrowableDiagnostic(`Unable to resolve ${pkg} from ${sourceFile} when resolving specifier ${specifier}`, dependency);
      }
      specifier = _path().default.resolve(_path().default.dirname(result.filePath), rest);
      if (result.invalidateOnFileChange) {
        for (let f of result.invalidateOnFileChange) {
          invalidateOnFileChange.add(f);
        }
      }
      if (result.invalidateOnFileCreate) {
        invalidateOnFileCreate.push(...result.invalidateOnFileCreate);
      }
    } else {
      specifier = _path().default.resolve(_path().default.dirname(sourceFile), specifier);
    }
    let normalized = (0, _utils().normalizeSeparators)(specifier);
    let files = await (0, _utils().glob)(normalized, options.inputFS, {
      onlyFiles: true
    });
    let dir = _path().default.dirname(sourceFile);
    let results = files.map(file => {
      let relative = (0, _utils().relativePath)(dir, file);
      if (pipeline) {
        relative = `${pipeline}:${relative}`;
      }
      return [file, relative];
    });
    let code = '';
    if (sourceAssetType === 'js') {
      let re = (0, _utils().globToRegex)(normalized, {
        capture: true
      });
      let matches = {};
      for (let [file, relative] of results) {
        let match = file.match(re);
        if (!match) continue;
        let parts = match.slice(1).filter(Boolean).reduce((a, p) => a.concat(p.split('/')), []);
        set(matches, parts, relative);
      }
      let {
        value,
        imports
      } = generate(matches, dependency.priority === 'lazy');
      code = imports + 'module.exports = ' + value;
    } else if (sourceAssetType === 'css') {
      for (let [, relative] of results) {
        code += `@import "${relative}";\n`;
      }
    }
    invalidateOnFileCreate.push({
      glob: normalized
    });
    return {
      filePath: _path().default.join(dir, _path().default.basename(specifier, _path().default.extname(specifier)) + '.' + sourceAssetType),
      code,
      invalidateOnFileCreate,
      invalidateOnFileChange: [...invalidateOnFileChange],
      pipeline: null,
      priority: 'sync'
    };
  }
});
exports.default = _default;
function set(obj, path, value) {
  for (let i = 0; i < path.length - 1; i++) {
    let part = path[i];
    if (obj[part] == null) {
      obj[part] = {};
    }
    obj = obj[part];
  }
  obj[path[path.length - 1]] = value;
}
function generate(matches, isAsync, indent = '', count = 0) {
  if (typeof matches === 'string') {
    if (isAsync) {
      return {
        imports: '',
        value: `() => import(${JSON.stringify(matches)})`,
        count
      };
    }
    let key = `_temp${count++}`;
    return {
      imports: `const ${key} = require(${JSON.stringify(matches)});`,
      value: key,
      count
    };
  }
  let imports = '';
  let res = indent + '{';
  let first = true;
  for (let key in matches) {
    if (!first) {
      res += ',';
    }
    let {
      imports: i,
      value,
      count: c
    } = generate(matches[key], isAsync, indent + '  ', count);
    imports += `${i}\n`;
    count = c;
    res += `\n${indent}  ${JSON.stringify(key)}: ${value}`;
    first = false;
  }
  res += '\n' + indent + '}';
  return {
    imports,
    value: res,
    count
  };
}